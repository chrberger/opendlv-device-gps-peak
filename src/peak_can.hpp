/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.6.3 Sat Jan 29 19:14:17 2022.
 */

#ifndef PEAK_CAN_H
#define PEAK_CAN_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

#define PEAK_CAN_BMC_ACCELERATION_FRAME_ID (0x600u)
#define PEAK_CAN_BMC_MAGNETIC_FIELD_FRAME_ID (0x601u)
#define PEAK_CAN_L3_GD20_ROTATION_A_FRAME_ID (0x610u)
#define PEAK_CAN_L3_GD20_ROTATION_B_FRAME_ID (0x611u)
#define PEAK_CAN_GPS_STATUS_FRAME_ID (0x620u)
#define PEAK_CAN_GPS_COURSE_SPEED_FRAME_ID (0x621u)
#define PEAK_CAN_GPS_POSITION_LONGITUDE_FRAME_ID (0x622u)
#define PEAK_CAN_GPS_POSITION_LATITUDE_FRAME_ID (0x623u)
#define PEAK_CAN_GPS_POSITION_ALTITUDE_FRAME_ID (0x624u)
#define PEAK_CAN_GPS_DELUSIONS_A_FRAME_ID (0x625u)
#define PEAK_CAN_GPS_DELUSIONS_B_FRAME_ID (0x626u)
#define PEAK_CAN_GPS_DATE_TIME_FRAME_ID (0x627u)
#define PEAK_CAN_IO_FRAME_ID (0x630u)
#define PEAK_CAN_RTC_DATE_TIME_FRAME_ID (0x640u)

/**
 * Signals in message BMC_Acceleration.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_bmc_acceleration_t {
    /**
     * Range: -5115.089514066496163682864450..5115.089514066496163682864450 (-20000..20000 mG)
     * Scale: 3.91
     * Offset: 0
     */
    int16_t acceleration_x;

    /**
     * Range: -5115.089514066496163682864450..5115.089514066496163682864450 (-20000..20000 mG)
     * Scale: 3.91
     * Offset: 0
     */
    int16_t acceleration_y;

    /**
     * Range: -5115.089514066496163682864450..5115.089514066496163682864450 (-20000..20000 mG)
     * Scale: 3.91
     * Offset: 0
     */
    int16_t acceleration_z;

    /**
     * Range: -128..127 (-40..87.5 deg C)
     * Scale: 0.5
     * Offset: 24
     */
    int8_t temperature;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vertical_axis;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t orientation;
};

/**
 * Signals in message BMC_MagneticField.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_bmc_magnetic_field_t {
    /**
     * Range: -32768..32767 (-9830.4..9830.1 microT)
     * Scale: 0.3
     * Offset: 0
     */
    int16_t magnetic_field_x;

    /**
     * Range: -32768..32767 (-9830.4..9830.1 microT)
     * Scale: 0.3
     * Offset: 0
     */
    int16_t magnetic_field_y;

    /**
     * Range: -32768..32767 (-9830.4..9830.1 microT)
     * Scale: 0.3
     * Offset: 0
     */
    int16_t magnetic_field_z;
};

/**
 * Signals in message L3GD20_Rotation_A.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_l3_gd20_rotation_a_t {
    /**
     * Range: -4000..4000 (-4000..4000 deg/s)
     * Scale: 1
     * Offset: 0
     */
    float rotation_x;

    /**
     * Range: -4000..4000 (-4000..4000 deg/s)
     * Scale: 1
     * Offset: 0
     */
    float rotation_y;
};

/**
 * Signals in message L3GD20_Rotation_B.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_l3_gd20_rotation_b_t {
    /**
     * Range: -4000..4000 (-4000..4000 deg/s)
     * Scale: 1
     * Offset: 0
     */
    float rotation_z;
};

/**
 * Signals in message GPS_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_gps_status_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_antenna_status;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_num_satellites;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_navigation_method;
};

/**
 * Signals in message GPS_CourseSpeed.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_gps_course_speed_t {
    /**
     * Range: 0..4294967295 (0..4294967295 deg)
     * Scale: 1
     * Offset: 0
     */
    float gps_course;

    /**
     * Range: 0..4294967295 (0..4294967295 km/h)
     * Scale: 1
     * Offset: 0
     */
    float gps_speed;
};

/**
 * Signals in message GPS_PositionLongitude.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_gps_position_longitude_t {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    float gps_longitude_minutes;

    /**
     * Range: 0..359 (0..359 deg)
     * Scale: 1
     * Offset: 0
     */
    uint16_t gps_longitude_degree;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_indicator_ew;
};

/**
 * Signals in message GPS_PositionLatitude.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_gps_position_latitude_t {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    float gps_latitude_minutes;

    /**
     * Range: 0..359 (0..359 deg)
     * Scale: 1
     * Offset: 0
     */
    uint16_t gps_latitude_degree;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_indicator_ns;
};

/**
 * Signals in message GPS_PositionAltitude.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_gps_position_altitude_t {
    /**
     * Range: 0..4294967295 (0..4294967295 m)
     * Scale: 1
     * Offset: 0
     */
    float gps_altitude;
};

/**
 * Signals in message GPS_Delusions_A.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_gps_delusions_a_t {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    float gps_pdop;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    float gps_hdop;
};

/**
 * Signals in message GPS_Delusions_B.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_gps_delusions_b_t {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    float gps_vdop;
};

/**
 * Signals in message GPS_DateTime.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_gps_date_time_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t utc_year;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t utc_month;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t utc_day_of_month;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t utc_hour;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t utc_minute;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t utc_second;
};

/**
 * Signals in message IO.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_io_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t din1_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t din2_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dout_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sd_present;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_power_status;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t device_id;
};

/**
 * Signals in message RTC_DateTime.
 *
 * All signal values are as on the CAN bus.
 */
struct peak_can_rtc_date_time_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rtc_sec;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rtc_min;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rtc_hour;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rtc_day_of_week;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rtc_day_of_month;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rtc_month;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rtc_year;
};

/**
 * Pack message BMC_Acceleration.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_bmc_acceleration_pack(
    uint8_t *dst_p,
    const struct peak_can_bmc_acceleration_t *src_p,
    size_t size);

/**
 * Unpack message BMC_Acceleration.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_bmc_acceleration_unpack(
    struct peak_can_bmc_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t peak_can_bmc_acceleration_acceleration_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_bmc_acceleration_acceleration_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_bmc_acceleration_acceleration_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t peak_can_bmc_acceleration_acceleration_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_bmc_acceleration_acceleration_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_bmc_acceleration_acceleration_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t peak_can_bmc_acceleration_acceleration_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_bmc_acceleration_acceleration_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_bmc_acceleration_acceleration_z_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t peak_can_bmc_acceleration_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_bmc_acceleration_temperature_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_bmc_acceleration_temperature_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_bmc_acceleration_vertical_axis_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_bmc_acceleration_vertical_axis_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_bmc_acceleration_vertical_axis_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_bmc_acceleration_orientation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_bmc_acceleration_orientation_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_bmc_acceleration_orientation_is_in_range(uint8_t value);

/**
 * Pack message BMC_MagneticField.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_bmc_magnetic_field_pack(
    uint8_t *dst_p,
    const struct peak_can_bmc_magnetic_field_t *src_p,
    size_t size);

/**
 * Unpack message BMC_MagneticField.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_bmc_magnetic_field_unpack(
    struct peak_can_bmc_magnetic_field_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t peak_can_bmc_magnetic_field_magnetic_field_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_bmc_magnetic_field_magnetic_field_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_bmc_magnetic_field_magnetic_field_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t peak_can_bmc_magnetic_field_magnetic_field_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_bmc_magnetic_field_magnetic_field_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_bmc_magnetic_field_magnetic_field_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t peak_can_bmc_magnetic_field_magnetic_field_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_bmc_magnetic_field_magnetic_field_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_bmc_magnetic_field_magnetic_field_z_is_in_range(int16_t value);

/**
 * Pack message L3GD20_Rotation_A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_l3_gd20_rotation_a_pack(
    uint8_t *dst_p,
    const struct peak_can_l3_gd20_rotation_a_t *src_p,
    size_t size);

/**
 * Unpack message L3GD20_Rotation_A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_l3_gd20_rotation_a_unpack(
    struct peak_can_l3_gd20_rotation_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_l3_gd20_rotation_a_rotation_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_l3_gd20_rotation_a_rotation_x_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_l3_gd20_rotation_a_rotation_x_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_l3_gd20_rotation_a_rotation_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_l3_gd20_rotation_a_rotation_y_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_l3_gd20_rotation_a_rotation_y_is_in_range(float value);

/**
 * Pack message L3GD20_Rotation_B.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_l3_gd20_rotation_b_pack(
    uint8_t *dst_p,
    const struct peak_can_l3_gd20_rotation_b_t *src_p,
    size_t size);

/**
 * Unpack message L3GD20_Rotation_B.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_l3_gd20_rotation_b_unpack(
    struct peak_can_l3_gd20_rotation_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_l3_gd20_rotation_b_rotation_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_l3_gd20_rotation_b_rotation_z_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_l3_gd20_rotation_b_rotation_z_is_in_range(float value);

/**
 * Pack message GPS_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_gps_status_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_status_t *src_p,
    size_t size);

/**
 * Unpack message GPS_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_gps_status_unpack(
    struct peak_can_gps_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_status_gps_antenna_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_status_gps_antenna_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_status_gps_antenna_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_status_gps_num_satellites_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_status_gps_num_satellites_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_status_gps_num_satellites_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_status_gps_navigation_method_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_status_gps_navigation_method_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_status_gps_navigation_method_is_in_range(uint8_t value);

/**
 * Pack message GPS_CourseSpeed.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_gps_course_speed_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_course_speed_t *src_p,
    size_t size);

/**
 * Unpack message GPS_CourseSpeed.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_gps_course_speed_unpack(
    struct peak_can_gps_course_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_gps_course_speed_gps_course_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_course_speed_gps_course_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_course_speed_gps_course_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_gps_course_speed_gps_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_course_speed_gps_speed_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_course_speed_gps_speed_is_in_range(float value);

/**
 * Pack message GPS_PositionLongitude.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_gps_position_longitude_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_position_longitude_t *src_p,
    size_t size);

/**
 * Unpack message GPS_PositionLongitude.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_gps_position_longitude_unpack(
    struct peak_can_gps_position_longitude_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_gps_position_longitude_gps_longitude_minutes_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_position_longitude_gps_longitude_minutes_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_position_longitude_gps_longitude_minutes_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t peak_can_gps_position_longitude_gps_longitude_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_position_longitude_gps_longitude_degree_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_position_longitude_gps_longitude_degree_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_position_longitude_gps_indicator_ew_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_position_longitude_gps_indicator_ew_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_position_longitude_gps_indicator_ew_is_in_range(uint8_t value);

/**
 * Pack message GPS_PositionLatitude.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_gps_position_latitude_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_position_latitude_t *src_p,
    size_t size);

/**
 * Unpack message GPS_PositionLatitude.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_gps_position_latitude_unpack(
    struct peak_can_gps_position_latitude_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_gps_position_latitude_gps_latitude_minutes_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_position_latitude_gps_latitude_minutes_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_position_latitude_gps_latitude_minutes_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t peak_can_gps_position_latitude_gps_latitude_degree_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_position_latitude_gps_latitude_degree_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_position_latitude_gps_latitude_degree_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_position_latitude_gps_indicator_ns_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_position_latitude_gps_indicator_ns_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_position_latitude_gps_indicator_ns_is_in_range(uint8_t value);

/**
 * Pack message GPS_PositionAltitude.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_gps_position_altitude_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_position_altitude_t *src_p,
    size_t size);

/**
 * Unpack message GPS_PositionAltitude.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_gps_position_altitude_unpack(
    struct peak_can_gps_position_altitude_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_gps_position_altitude_gps_altitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_position_altitude_gps_altitude_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_position_altitude_gps_altitude_is_in_range(float value);

/**
 * Pack message GPS_Delusions_A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_gps_delusions_a_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_delusions_a_t *src_p,
    size_t size);

/**
 * Unpack message GPS_Delusions_A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_gps_delusions_a_unpack(
    struct peak_can_gps_delusions_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_gps_delusions_a_gps_pdop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_delusions_a_gps_pdop_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_delusions_a_gps_pdop_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_gps_delusions_a_gps_hdop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_delusions_a_gps_hdop_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_delusions_a_gps_hdop_is_in_range(float value);

/**
 * Pack message GPS_Delusions_B.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_gps_delusions_b_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_delusions_b_t *src_p,
    size_t size);

/**
 * Unpack message GPS_Delusions_B.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_gps_delusions_b_unpack(
    struct peak_can_gps_delusions_b_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float peak_can_gps_delusions_b_gps_vdop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_delusions_b_gps_vdop_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_delusions_b_gps_vdop_is_in_range(float value);

/**
 * Pack message GPS_DateTime.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_gps_date_time_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_date_time_t *src_p,
    size_t size);

/**
 * Unpack message GPS_DateTime.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_gps_date_time_unpack(
    struct peak_can_gps_date_time_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_date_time_utc_year_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_date_time_utc_year_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_date_time_utc_year_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_date_time_utc_month_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_date_time_utc_month_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_date_time_utc_month_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_date_time_utc_day_of_month_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_date_time_utc_day_of_month_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_date_time_utc_day_of_month_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_date_time_utc_hour_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_date_time_utc_hour_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_date_time_utc_hour_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_date_time_utc_minute_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_date_time_utc_minute_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_date_time_utc_minute_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_gps_date_time_utc_second_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_gps_date_time_utc_second_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_gps_date_time_utc_second_is_in_range(uint8_t value);

/**
 * Pack message IO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_io_pack(
    uint8_t *dst_p,
    const struct peak_can_io_t *src_p,
    size_t size);

/**
 * Unpack message IO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_io_unpack(
    struct peak_can_io_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_io_din1_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_io_din1_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_io_din1_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_io_din2_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_io_din2_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_io_din2_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_io_dout_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_io_dout_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_io_dout_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_io_sd_present_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_io_sd_present_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_io_sd_present_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_io_gps_power_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_io_gps_power_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_io_gps_power_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_io_device_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_io_device_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_io_device_id_is_in_range(uint8_t value);

/**
 * Pack message RTC_DateTime.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int peak_can_rtc_date_time_pack(
    uint8_t *dst_p,
    const struct peak_can_rtc_date_time_t *src_p,
    size_t size);

/**
 * Unpack message RTC_DateTime.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int peak_can_rtc_date_time_unpack(
    struct peak_can_rtc_date_time_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_rtc_date_time_rtc_sec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_rtc_date_time_rtc_sec_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_rtc_date_time_rtc_sec_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_rtc_date_time_rtc_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_rtc_date_time_rtc_min_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_rtc_date_time_rtc_min_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_rtc_date_time_rtc_hour_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_rtc_date_time_rtc_hour_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_rtc_date_time_rtc_hour_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_rtc_date_time_rtc_day_of_week_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_rtc_date_time_rtc_day_of_week_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_rtc_date_time_rtc_day_of_week_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_rtc_date_time_rtc_day_of_month_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_rtc_date_time_rtc_day_of_month_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_rtc_date_time_rtc_day_of_month_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t peak_can_rtc_date_time_rtc_month_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_rtc_date_time_rtc_month_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_rtc_date_time_rtc_month_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t peak_can_rtc_date_time_rtc_year_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double peak_can_rtc_date_time_rtc_year_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool peak_can_rtc_date_time_rtc_year_is_in_range(uint16_t value);

#endif
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.6.3 Sat Jan 29 19:14:17 2022.
 */

#include <string.h>

//#include "peak_can.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int peak_can_bmc_acceleration_pack(
    uint8_t *dst_p,
    const struct peak_can_bmc_acceleration_t *src_p,
    size_t size)
{
    uint16_t acceleration_x;
    uint16_t acceleration_y;
    uint16_t acceleration_z;
    uint8_t temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    acceleration_x = (uint16_t)src_p->acceleration_x;
    dst_p[0] |= pack_left_shift_u16(acceleration_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(acceleration_x, 8u, 0xffu);
    acceleration_y = (uint16_t)src_p->acceleration_y;
    dst_p[2] |= pack_left_shift_u16(acceleration_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(acceleration_y, 8u, 0xffu);
    acceleration_z = (uint16_t)src_p->acceleration_z;
    dst_p[4] |= pack_left_shift_u16(acceleration_z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(acceleration_z, 8u, 0xffu);
    temperature = (uint8_t)src_p->temperature;
    dst_p[6] |= pack_left_shift_u8(temperature, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->vertical_axis, 0u, 0x03u);
    dst_p[7] |= pack_left_shift_u8(src_p->orientation, 2u, 0x1cu);

    return (8);
}

int peak_can_bmc_acceleration_unpack(
    struct peak_can_bmc_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t acceleration_x;
    uint16_t acceleration_y;
    uint16_t acceleration_z;
    uint8_t temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    acceleration_x = 0u;
    acceleration_x |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    acceleration_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->acceleration_x = (int16_t)acceleration_x;
    acceleration_y = 0u;
    acceleration_y |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    acceleration_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->acceleration_y = (int16_t)acceleration_y;
    acceleration_z = 0u;
    acceleration_z |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    acceleration_z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->acceleration_z = (int16_t)acceleration_z;
    temperature = 0u;
    temperature |= unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->temperature = (int8_t)temperature;
    dst_p->vertical_axis |= unpack_right_shift_u8(src_p[7], 0u, 0x03u);
    dst_p->orientation |= unpack_right_shift_u8(src_p[7], 2u, 0x1cu);

    return (0);
}

int16_t peak_can_bmc_acceleration_acceleration_x_encode(double value)
{
    return (int16_t)(value / 3.91);
}

double peak_can_bmc_acceleration_acceleration_x_decode(int16_t value)
{
    return ((double)value * 3.91);
}

bool peak_can_bmc_acceleration_acceleration_x_is_in_range(int16_t value)
{
    return ((value >= -5115) && (value <= 5115));
}

int16_t peak_can_bmc_acceleration_acceleration_y_encode(double value)
{
    return (int16_t)(value / 3.91);
}

double peak_can_bmc_acceleration_acceleration_y_decode(int16_t value)
{
    return ((double)value * 3.91);
}

bool peak_can_bmc_acceleration_acceleration_y_is_in_range(int16_t value)
{
    return ((value >= -5115) && (value <= 5115));
}

int16_t peak_can_bmc_acceleration_acceleration_z_encode(double value)
{
    return (int16_t)(value / 3.91);
}

double peak_can_bmc_acceleration_acceleration_z_decode(int16_t value)
{
    return ((double)value * 3.91);
}

bool peak_can_bmc_acceleration_acceleration_z_is_in_range(int16_t value)
{
    return ((value >= -5115) && (value <= 5115));
}

int8_t peak_can_bmc_acceleration_temperature_encode(double value)
{
    return (int8_t)((value - 24.0) / 0.5);
}

double peak_can_bmc_acceleration_temperature_decode(int8_t value)
{
    return (((double)value * 0.5) + 24.0);
}

bool peak_can_bmc_acceleration_temperature_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_bmc_acceleration_vertical_axis_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_bmc_acceleration_vertical_axis_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_bmc_acceleration_vertical_axis_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t peak_can_bmc_acceleration_orientation_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_bmc_acceleration_orientation_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_bmc_acceleration_orientation_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

int peak_can_bmc_magnetic_field_pack(
    uint8_t *dst_p,
    const struct peak_can_bmc_magnetic_field_t *src_p,
    size_t size)
{
    uint16_t magnetic_field_x;
    uint16_t magnetic_field_y;
    uint16_t magnetic_field_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    magnetic_field_x = (uint16_t)src_p->magnetic_field_x;
    dst_p[0] |= pack_left_shift_u16(magnetic_field_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(magnetic_field_x, 8u, 0xffu);
    magnetic_field_y = (uint16_t)src_p->magnetic_field_y;
    dst_p[2] |= pack_left_shift_u16(magnetic_field_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(magnetic_field_y, 8u, 0xffu);
    magnetic_field_z = (uint16_t)src_p->magnetic_field_z;
    dst_p[4] |= pack_left_shift_u16(magnetic_field_z, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(magnetic_field_z, 8u, 0xffu);

    return (6);
}

int peak_can_bmc_magnetic_field_unpack(
    struct peak_can_bmc_magnetic_field_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t magnetic_field_x;
    uint16_t magnetic_field_y;
    uint16_t magnetic_field_z;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    magnetic_field_x = 0u;
    magnetic_field_x |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    magnetic_field_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->magnetic_field_x = (int16_t)magnetic_field_x;
    magnetic_field_y = 0u;
    magnetic_field_y |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    magnetic_field_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->magnetic_field_y = (int16_t)magnetic_field_y;
    magnetic_field_z = 0u;
    magnetic_field_z |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    magnetic_field_z |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->magnetic_field_z = (int16_t)magnetic_field_z;

    return (0);
}

int16_t peak_can_bmc_magnetic_field_magnetic_field_x_encode(double value)
{
    return (int16_t)(value / 0.3);
}

double peak_can_bmc_magnetic_field_magnetic_field_x_decode(int16_t value)
{
    return ((double)value * 0.3);
}

bool peak_can_bmc_magnetic_field_magnetic_field_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t peak_can_bmc_magnetic_field_magnetic_field_y_encode(double value)
{
    return (int16_t)(value / 0.3);
}

double peak_can_bmc_magnetic_field_magnetic_field_y_decode(int16_t value)
{
    return ((double)value * 0.3);
}

bool peak_can_bmc_magnetic_field_magnetic_field_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t peak_can_bmc_magnetic_field_magnetic_field_z_encode(double value)
{
    return (int16_t)(value / 0.3);
}

double peak_can_bmc_magnetic_field_magnetic_field_z_decode(int16_t value)
{
    return ((double)value * 0.3);
}

bool peak_can_bmc_magnetic_field_magnetic_field_z_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int peak_can_l3_gd20_rotation_a_pack(
    uint8_t *dst_p,
    const struct peak_can_l3_gd20_rotation_a_t *src_p,
    size_t size)
{
    uint32_t rotation_x;
    uint32_t rotation_y;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&rotation_x, &src_p->rotation_x, sizeof(rotation_x));
    dst_p[0] |= pack_left_shift_u32(rotation_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(rotation_x, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(rotation_x, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(rotation_x, 24u, 0xffu);
    memcpy(&rotation_y, &src_p->rotation_y, sizeof(rotation_y));
    dst_p[4] |= pack_left_shift_u32(rotation_y, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(rotation_y, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(rotation_y, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(rotation_y, 24u, 0xffu);

    return (8);
}

int peak_can_l3_gd20_rotation_a_unpack(
    struct peak_can_l3_gd20_rotation_a_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t rotation_x;
    uint32_t rotation_y;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    rotation_x = 0u;
    rotation_x |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    rotation_x |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    rotation_x |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    rotation_x |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->rotation_x, &rotation_x, sizeof(dst_p->rotation_x));
    rotation_y = 0u;
    rotation_y |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    rotation_y |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    rotation_y |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    rotation_y |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->rotation_y, &rotation_y, sizeof(dst_p->rotation_y));

    return (0);
}

float peak_can_l3_gd20_rotation_a_rotation_x_encode(double value)
{
    return (float)(value);
}

double peak_can_l3_gd20_rotation_a_rotation_x_decode(float value)
{
    return ((double)value);
}

bool peak_can_l3_gd20_rotation_a_rotation_x_is_in_range(float value)
{
    return ((value >= -4000.0f) && (value <= 4000.0f));
}

float peak_can_l3_gd20_rotation_a_rotation_y_encode(double value)
{
    return (float)(value);
}

double peak_can_l3_gd20_rotation_a_rotation_y_decode(float value)
{
    return ((double)value);
}

bool peak_can_l3_gd20_rotation_a_rotation_y_is_in_range(float value)
{
    return ((value >= -4000.0f) && (value <= 4000.0f));
}

int peak_can_l3_gd20_rotation_b_pack(
    uint8_t *dst_p,
    const struct peak_can_l3_gd20_rotation_b_t *src_p,
    size_t size)
{
    uint32_t rotation_z;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&rotation_z, &src_p->rotation_z, sizeof(rotation_z));
    dst_p[0] |= pack_left_shift_u32(rotation_z, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(rotation_z, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(rotation_z, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(rotation_z, 24u, 0xffu);

    return (4);
}

int peak_can_l3_gd20_rotation_b_unpack(
    struct peak_can_l3_gd20_rotation_b_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t rotation_z;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    rotation_z = 0u;
    rotation_z |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    rotation_z |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    rotation_z |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    rotation_z |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->rotation_z, &rotation_z, sizeof(dst_p->rotation_z));

    return (0);
}

float peak_can_l3_gd20_rotation_b_rotation_z_encode(double value)
{
    return (float)(value);
}

double peak_can_l3_gd20_rotation_b_rotation_z_decode(float value)
{
    return ((double)value);
}

bool peak_can_l3_gd20_rotation_b_rotation_z_is_in_range(float value)
{
    return ((value >= -4000.0f) && (value <= 4000.0f));
}

int peak_can_gps_status_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_status_t *src_p,
    size_t size)
{
    if (size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    dst_p[0] |= pack_left_shift_u8(src_p->gps_antenna_status, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->gps_num_satellites, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->gps_navigation_method, 0u, 0xffu);

    return (3);
}

int peak_can_gps_status_unpack(
    struct peak_can_gps_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 3u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->gps_antenna_status |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->gps_num_satellites |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->gps_navigation_method |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);

    return (0);
}

uint8_t peak_can_gps_status_gps_antenna_status_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_status_gps_antenna_status_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_status_gps_antenna_status_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_gps_status_gps_num_satellites_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_status_gps_num_satellites_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_status_gps_num_satellites_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_gps_status_gps_navigation_method_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_status_gps_navigation_method_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_status_gps_navigation_method_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int peak_can_gps_course_speed_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_course_speed_t *src_p,
    size_t size)
{
    uint32_t gps_course;
    uint32_t gps_speed;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&gps_course, &src_p->gps_course, sizeof(gps_course));
    dst_p[0] |= pack_left_shift_u32(gps_course, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(gps_course, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(gps_course, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(gps_course, 24u, 0xffu);
    memcpy(&gps_speed, &src_p->gps_speed, sizeof(gps_speed));
    dst_p[4] |= pack_left_shift_u32(gps_speed, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(gps_speed, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(gps_speed, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(gps_speed, 24u, 0xffu);

    return (8);
}

int peak_can_gps_course_speed_unpack(
    struct peak_can_gps_course_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t gps_course;
    uint32_t gps_speed;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    gps_course = 0u;
    gps_course |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    gps_course |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    gps_course |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    gps_course |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->gps_course, &gps_course, sizeof(dst_p->gps_course));
    gps_speed = 0u;
    gps_speed |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    gps_speed |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    gps_speed |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    gps_speed |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->gps_speed, &gps_speed, sizeof(dst_p->gps_speed));

    return (0);
}

float peak_can_gps_course_speed_gps_course_encode(double value)
{
    return (float)(value);
}

double peak_can_gps_course_speed_gps_course_decode(float value)
{
    return ((double)value);
}

bool peak_can_gps_course_speed_gps_course_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 4294967295.0f));
}

float peak_can_gps_course_speed_gps_speed_encode(double value)
{
    return (float)(value);
}

double peak_can_gps_course_speed_gps_speed_decode(float value)
{
    return ((double)value);
}

bool peak_can_gps_course_speed_gps_speed_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 4294967295.0f));
}

int peak_can_gps_position_longitude_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_position_longitude_t *src_p,
    size_t size)
{
    uint32_t gps_longitude_minutes;

    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    memcpy(&gps_longitude_minutes, &src_p->gps_longitude_minutes, sizeof(gps_longitude_minutes));
    dst_p[0] |= pack_left_shift_u32(gps_longitude_minutes, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(gps_longitude_minutes, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(gps_longitude_minutes, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(gps_longitude_minutes, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->gps_longitude_degree, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->gps_longitude_degree, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->gps_indicator_ew, 0u, 0xffu);

    return (7);
}

int peak_can_gps_position_longitude_unpack(
    struct peak_can_gps_position_longitude_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t gps_longitude_minutes;

    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    gps_longitude_minutes = 0u;
    gps_longitude_minutes |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    gps_longitude_minutes |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    gps_longitude_minutes |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    gps_longitude_minutes |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->gps_longitude_minutes, &gps_longitude_minutes, sizeof(dst_p->gps_longitude_minutes));
    dst_p->gps_longitude_degree |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->gps_longitude_degree |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->gps_indicator_ew |= unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

float peak_can_gps_position_longitude_gps_longitude_minutes_encode(double value)
{
    return (float)(value);
}

double peak_can_gps_position_longitude_gps_longitude_minutes_decode(float value)
{
    return ((double)value);
}

bool peak_can_gps_position_longitude_gps_longitude_minutes_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 4294967295.0f));
}

uint16_t peak_can_gps_position_longitude_gps_longitude_degree_encode(double value)
{
    return (uint16_t)(value);
}

double peak_can_gps_position_longitude_gps_longitude_degree_decode(uint16_t value)
{
    return ((double)value);
}

bool peak_can_gps_position_longitude_gps_longitude_degree_is_in_range(uint16_t value)
{
    return (value <= 359u);
}

uint8_t peak_can_gps_position_longitude_gps_indicator_ew_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_position_longitude_gps_indicator_ew_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_position_longitude_gps_indicator_ew_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int peak_can_gps_position_latitude_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_position_latitude_t *src_p,
    size_t size)
{
    uint32_t gps_latitude_minutes;

    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    memcpy(&gps_latitude_minutes, &src_p->gps_latitude_minutes, sizeof(gps_latitude_minutes));
    dst_p[0] |= pack_left_shift_u32(gps_latitude_minutes, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(gps_latitude_minutes, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(gps_latitude_minutes, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(gps_latitude_minutes, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->gps_latitude_degree, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->gps_latitude_degree, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->gps_indicator_ns, 0u, 0xffu);

    return (7);
}

int peak_can_gps_position_latitude_unpack(
    struct peak_can_gps_position_latitude_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t gps_latitude_minutes;

    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    gps_latitude_minutes = 0u;
    gps_latitude_minutes |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    gps_latitude_minutes |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    gps_latitude_minutes |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    gps_latitude_minutes |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->gps_latitude_minutes, &gps_latitude_minutes, sizeof(dst_p->gps_latitude_minutes));
    dst_p->gps_latitude_degree |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->gps_latitude_degree |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->gps_indicator_ns |= unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

float peak_can_gps_position_latitude_gps_latitude_minutes_encode(double value)
{
    return (float)(value);
}

double peak_can_gps_position_latitude_gps_latitude_minutes_decode(float value)
{
    return ((double)value);
}

bool peak_can_gps_position_latitude_gps_latitude_minutes_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 4294967295.0f));
}

uint16_t peak_can_gps_position_latitude_gps_latitude_degree_encode(double value)
{
    return (uint16_t)(value);
}

double peak_can_gps_position_latitude_gps_latitude_degree_decode(uint16_t value)
{
    return ((double)value);
}

bool peak_can_gps_position_latitude_gps_latitude_degree_is_in_range(uint16_t value)
{
    return (value <= 359u);
}

uint8_t peak_can_gps_position_latitude_gps_indicator_ns_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_position_latitude_gps_indicator_ns_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_position_latitude_gps_indicator_ns_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int peak_can_gps_position_altitude_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_position_altitude_t *src_p,
    size_t size)
{
    uint32_t gps_altitude;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&gps_altitude, &src_p->gps_altitude, sizeof(gps_altitude));
    dst_p[0] |= pack_left_shift_u32(gps_altitude, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(gps_altitude, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(gps_altitude, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(gps_altitude, 24u, 0xffu);

    return (4);
}

int peak_can_gps_position_altitude_unpack(
    struct peak_can_gps_position_altitude_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t gps_altitude;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    gps_altitude = 0u;
    gps_altitude |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    gps_altitude |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    gps_altitude |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    gps_altitude |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->gps_altitude, &gps_altitude, sizeof(dst_p->gps_altitude));

    return (0);
}

float peak_can_gps_position_altitude_gps_altitude_encode(double value)
{
    return (float)(value);
}

double peak_can_gps_position_altitude_gps_altitude_decode(float value)
{
    return ((double)value);
}

bool peak_can_gps_position_altitude_gps_altitude_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 4294967295.0f));
}

int peak_can_gps_delusions_a_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_delusions_a_t *src_p,
    size_t size)
{
    uint32_t gps_hdop;
    uint32_t gps_pdop;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&gps_pdop, &src_p->gps_pdop, sizeof(gps_pdop));
    dst_p[0] |= pack_left_shift_u32(gps_pdop, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(gps_pdop, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(gps_pdop, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(gps_pdop, 24u, 0xffu);
    memcpy(&gps_hdop, &src_p->gps_hdop, sizeof(gps_hdop));
    dst_p[4] |= pack_left_shift_u32(gps_hdop, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(gps_hdop, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(gps_hdop, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(gps_hdop, 24u, 0xffu);

    return (8);
}

int peak_can_gps_delusions_a_unpack(
    struct peak_can_gps_delusions_a_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t gps_hdop;
    uint32_t gps_pdop;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    gps_pdop = 0u;
    gps_pdop |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    gps_pdop |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    gps_pdop |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    gps_pdop |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->gps_pdop, &gps_pdop, sizeof(dst_p->gps_pdop));
    gps_hdop = 0u;
    gps_hdop |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    gps_hdop |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    gps_hdop |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    gps_hdop |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->gps_hdop, &gps_hdop, sizeof(dst_p->gps_hdop));

    return (0);
}

float peak_can_gps_delusions_a_gps_pdop_encode(double value)
{
    return (float)(value);
}

double peak_can_gps_delusions_a_gps_pdop_decode(float value)
{
    return ((double)value);
}

bool peak_can_gps_delusions_a_gps_pdop_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 4294967295.0f));
}

float peak_can_gps_delusions_a_gps_hdop_encode(double value)
{
    return (float)(value);
}

double peak_can_gps_delusions_a_gps_hdop_decode(float value)
{
    return ((double)value);
}

bool peak_can_gps_delusions_a_gps_hdop_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 4294967295.0f));
}

int peak_can_gps_delusions_b_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_delusions_b_t *src_p,
    size_t size)
{
    uint32_t gps_vdop;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&gps_vdop, &src_p->gps_vdop, sizeof(gps_vdop));
    dst_p[0] |= pack_left_shift_u32(gps_vdop, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(gps_vdop, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(gps_vdop, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(gps_vdop, 24u, 0xffu);

    return (4);
}

int peak_can_gps_delusions_b_unpack(
    struct peak_can_gps_delusions_b_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t gps_vdop;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    gps_vdop = 0u;
    gps_vdop |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    gps_vdop |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    gps_vdop |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    gps_vdop |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->gps_vdop, &gps_vdop, sizeof(dst_p->gps_vdop));

    return (0);
}

float peak_can_gps_delusions_b_gps_vdop_encode(double value)
{
    return (float)(value);
}

double peak_can_gps_delusions_b_gps_vdop_decode(float value)
{
    return ((double)value);
}

bool peak_can_gps_delusions_b_gps_vdop_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 4294967295.0f));
}

int peak_can_gps_date_time_pack(
    uint8_t *dst_p,
    const struct peak_can_gps_date_time_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_left_shift_u8(src_p->utc_year, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->utc_month, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->utc_day_of_month, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->utc_hour, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->utc_minute, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->utc_second, 0u, 0xffu);

    return (6);
}

int peak_can_gps_date_time_unpack(
    struct peak_can_gps_date_time_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->utc_year |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->utc_month |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->utc_day_of_month |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->utc_hour |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->utc_minute |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->utc_second |= unpack_right_shift_u8(src_p[5], 0u, 0xffu);

    return (0);
}

uint8_t peak_can_gps_date_time_utc_year_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_date_time_utc_year_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_date_time_utc_year_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_gps_date_time_utc_month_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_date_time_utc_month_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_date_time_utc_month_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_gps_date_time_utc_day_of_month_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_date_time_utc_day_of_month_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_date_time_utc_day_of_month_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_gps_date_time_utc_hour_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_date_time_utc_hour_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_date_time_utc_hour_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_gps_date_time_utc_minute_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_date_time_utc_minute_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_date_time_utc_minute_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_gps_date_time_utc_second_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_gps_date_time_utc_second_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_gps_date_time_utc_second_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int peak_can_io_pack(
    uint8_t *dst_p,
    const struct peak_can_io_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->din1_status, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->din2_status, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->dout_status, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->sd_present, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->gps_power_status, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->device_id, 5u, 0xe0u);

    return (1);
}

int peak_can_io_unpack(
    struct peak_can_io_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->din1_status |= unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->din2_status |= unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->dout_status |= unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->sd_present |= unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->gps_power_status |= unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->device_id |= unpack_right_shift_u8(src_p[0], 5u, 0xe0u);

    return (0);
}

uint8_t peak_can_io_din1_status_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_io_din1_status_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_io_din1_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t peak_can_io_din2_status_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_io_din2_status_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_io_din2_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t peak_can_io_dout_status_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_io_dout_status_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_io_dout_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t peak_can_io_sd_present_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_io_sd_present_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_io_sd_present_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t peak_can_io_gps_power_status_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_io_gps_power_status_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_io_gps_power_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t peak_can_io_device_id_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_io_device_id_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_io_device_id_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

int peak_can_rtc_date_time_pack(
    uint8_t *dst_p,
    const struct peak_can_rtc_date_time_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->rtc_sec, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->rtc_min, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->rtc_hour, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->rtc_day_of_week, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->rtc_day_of_month, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->rtc_month, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->rtc_year, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->rtc_year, 8u, 0xffu);

    return (8);
}

int peak_can_rtc_date_time_unpack(
    struct peak_can_rtc_date_time_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->rtc_sec |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->rtc_min |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->rtc_hour |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->rtc_day_of_week |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->rtc_day_of_month |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->rtc_month |= unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->rtc_year |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->rtc_year |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint8_t peak_can_rtc_date_time_rtc_sec_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_rtc_date_time_rtc_sec_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_rtc_date_time_rtc_sec_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_rtc_date_time_rtc_min_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_rtc_date_time_rtc_min_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_rtc_date_time_rtc_min_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_rtc_date_time_rtc_hour_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_rtc_date_time_rtc_hour_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_rtc_date_time_rtc_hour_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_rtc_date_time_rtc_day_of_week_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_rtc_date_time_rtc_day_of_week_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_rtc_date_time_rtc_day_of_week_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_rtc_date_time_rtc_day_of_month_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_rtc_date_time_rtc_day_of_month_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_rtc_date_time_rtc_day_of_month_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t peak_can_rtc_date_time_rtc_month_encode(double value)
{
    return (uint8_t)(value);
}

double peak_can_rtc_date_time_rtc_month_decode(uint8_t value)
{
    return ((double)value);
}

bool peak_can_rtc_date_time_rtc_month_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t peak_can_rtc_date_time_rtc_year_encode(double value)
{
    return (uint16_t)(value);
}

double peak_can_rtc_date_time_rtc_year_decode(uint16_t value)
{
    return ((double)value);
}

bool peak_can_rtc_date_time_rtc_year_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_DEVICE_GPS_PEAK_ACCELERATION_HPP
#define OPENDLV_DEVICE_GPS_PEAK_ACCELERATION_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace device { namespace gps { namespace peak {
using namespace std::string_literals; // NOLINT
class LIB_API Acceleration {
    private:
        static constexpr const char* TheShortName = "Acceleration";
        static constexpr const char* TheLongName = "opendlv.device.gps.peak.Acceleration";

    public:
        inline static int32_t ID() {
            return 1801;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        Acceleration() = default;
        Acceleration(const Acceleration&) = default;
        Acceleration& operator=(const Acceleration&) = default;
        Acceleration(Acceleration&&) = default;
        Acceleration& operator=(Acceleration&&) = default;
        ~Acceleration() = default;

    public:
        
        inline Acceleration& accelerationX(const float &v) noexcept {
            m_accelerationX = v;
            return *this;
        }
        inline float accelerationX() const noexcept {
            return m_accelerationX;
        }
        
        inline Acceleration& accelerationY(const float &v) noexcept {
            m_accelerationY = v;
            return *this;
        }
        inline float accelerationY() const noexcept {
            return m_accelerationY;
        }
        
        inline Acceleration& accelerationZ(const float &v) noexcept {
            m_accelerationZ = v;
            return *this;
        }
        inline float accelerationZ() const noexcept {
            return m_accelerationZ;
        }
        
        inline Acceleration& verticalAxis(const uint8_t &v) noexcept {
            m_verticalAxis = v;
            return *this;
        }
        inline uint8_t verticalAxis() const noexcept {
            return m_verticalAxis;
        }
        
        inline Acceleration& orientation(const uint8_t &v) noexcept {
            m_orientation = v;
            return *this;
        }
        inline uint8_t orientation() const noexcept {
            return m_orientation;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("float"s), std::move("accelerationX"s), m_accelerationX, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("float"s), std::move("accelerationY"s), m_accelerationY, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("float"s), std::move("accelerationZ"s), m_accelerationZ, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("uint8_t"s), std::move("verticalAxis"s), m_verticalAxis, visitor);
                return;
            }
            
            if (5 == fieldId) {
                doVisit(5, std::move("uint8_t"s), std::move("orientation"s), m_orientation, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("float"s), std::move("accelerationX"s), m_accelerationX, visitor);
            
            doVisit(2, std::move("float"s), std::move("accelerationY"s), m_accelerationY, visitor);
            
            doVisit(3, std::move("float"s), std::move("accelerationZ"s), m_accelerationZ, visitor);
            
            doVisit(4, std::move("uint8_t"s), std::move("verticalAxis"s), m_verticalAxis, visitor);
            
            doVisit(5, std::move("uint8_t"s), std::move("orientation"s), m_orientation, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("float"s), std::move("accelerationX"s), m_accelerationX, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("float"s), std::move("accelerationY"s), m_accelerationY, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("float"s), std::move("accelerationZ"s), m_accelerationZ, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("uint8_t"s), std::move("verticalAxis"s), m_verticalAxis, preVisit, visit, postVisit);
            
            doTripletForwardVisit(5, std::move("uint8_t"s), std::move("orientation"s), m_orientation, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        float m_accelerationX{ 0.0f }; // field identifier = 1.
        
        float m_accelerationY{ 0.0f }; // field identifier = 2.
        
        float m_accelerationZ{ 0.0f }; // field identifier = 3.
        
        uint8_t m_verticalAxis{ 0 }; // field identifier = 4.
        
        uint8_t m_orientation{ 0 }; // field identifier = 5.
        
};
}}}}

template<>
struct isVisitable<opendlv::device::gps::peak::Acceleration> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::device::gps::peak::Acceleration> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_DEVICE_GPS_PEAK_GPSSTATUS_HPP
#define OPENDLV_DEVICE_GPS_PEAK_GPSSTATUS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace device { namespace gps { namespace peak {
using namespace std::string_literals; // NOLINT
class LIB_API GPSStatus {
    private:
        static constexpr const char* TheShortName = "GPSStatus";
        static constexpr const char* TheLongName = "opendlv.device.gps.peak.GPSStatus";

    public:
        inline static int32_t ID() {
            return 1802;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        GPSStatus() = default;
        GPSStatus(const GPSStatus&) = default;
        GPSStatus& operator=(const GPSStatus&) = default;
        GPSStatus(GPSStatus&&) = default;
        GPSStatus& operator=(GPSStatus&&) = default;
        ~GPSStatus() = default;

    public:
        
        inline GPSStatus& antennaStatus(const uint8_t &v) noexcept {
            m_antennaStatus = v;
            return *this;
        }
        inline uint8_t antennaStatus() const noexcept {
            return m_antennaStatus;
        }
        
        inline GPSStatus& numberOfSatellites(const uint8_t &v) noexcept {
            m_numberOfSatellites = v;
            return *this;
        }
        inline uint8_t numberOfSatellites() const noexcept {
            return m_numberOfSatellites;
        }
        
        inline GPSStatus& navigationMethod(const uint8_t &v) noexcept {
            m_navigationMethod = v;
            return *this;
        }
        inline uint8_t navigationMethod() const noexcept {
            return m_navigationMethod;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("uint8_t"s), std::move("antennaStatus"s), m_antennaStatus, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("uint8_t"s), std::move("numberOfSatellites"s), m_numberOfSatellites, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("uint8_t"s), std::move("navigationMethod"s), m_navigationMethod, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("uint8_t"s), std::move("antennaStatus"s), m_antennaStatus, visitor);
            
            doVisit(2, std::move("uint8_t"s), std::move("numberOfSatellites"s), m_numberOfSatellites, visitor);
            
            doVisit(3, std::move("uint8_t"s), std::move("navigationMethod"s), m_navigationMethod, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("uint8_t"s), std::move("antennaStatus"s), m_antennaStatus, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("uint8_t"s), std::move("numberOfSatellites"s), m_numberOfSatellites, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("uint8_t"s), std::move("navigationMethod"s), m_navigationMethod, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        uint8_t m_antennaStatus{ 0 }; // field identifier = 1.
        
        uint8_t m_numberOfSatellites{ 0 }; // field identifier = 2.
        
        uint8_t m_navigationMethod{ 0 }; // field identifier = 3.
        
};
}}}}

template<>
struct isVisitable<opendlv::device::gps::peak::GPSStatus> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::device::gps::peak::GPSStatus> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_DEVICE_GPS_PEAK_DELUSION_HPP
#define OPENDLV_DEVICE_GPS_PEAK_DELUSION_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace device { namespace gps { namespace peak {
using namespace std::string_literals; // NOLINT
class LIB_API Delusion {
    private:
        static constexpr const char* TheShortName = "Delusion";
        static constexpr const char* TheLongName = "opendlv.device.gps.peak.Delusion";

    public:
        inline static int32_t ID() {
            return 1803;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        Delusion() = default;
        Delusion(const Delusion&) = default;
        Delusion& operator=(const Delusion&) = default;
        Delusion(Delusion&&) = default;
        Delusion& operator=(Delusion&&) = default;
        ~Delusion() = default;

    public:
        
        inline Delusion& GPS_PDOP(const float &v) noexcept {
            m_GPS_PDOP = v;
            return *this;
        }
        inline float GPS_PDOP() const noexcept {
            return m_GPS_PDOP;
        }
        
        inline Delusion& GPS_HDOP(const float &v) noexcept {
            m_GPS_HDOP = v;
            return *this;
        }
        inline float GPS_HDOP() const noexcept {
            return m_GPS_HDOP;
        }
        
        inline Delusion& GPS_VDOP(const float &v) noexcept {
            m_GPS_VDOP = v;
            return *this;
        }
        inline float GPS_VDOP() const noexcept {
            return m_GPS_VDOP;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("float"s), std::move("GPS_PDOP"s), m_GPS_PDOP, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("float"s), std::move("GPS_HDOP"s), m_GPS_HDOP, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("float"s), std::move("GPS_VDOP"s), m_GPS_VDOP, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("float"s), std::move("GPS_PDOP"s), m_GPS_PDOP, visitor);
            
            doVisit(2, std::move("float"s), std::move("GPS_HDOP"s), m_GPS_HDOP, visitor);
            
            doVisit(3, std::move("float"s), std::move("GPS_VDOP"s), m_GPS_VDOP, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("float"s), std::move("GPS_PDOP"s), m_GPS_PDOP, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("float"s), std::move("GPS_HDOP"s), m_GPS_HDOP, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("float"s), std::move("GPS_VDOP"s), m_GPS_VDOP, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        float m_GPS_PDOP{ 0.0f }; // field identifier = 1.
        
        float m_GPS_HDOP{ 0.0f }; // field identifier = 2.
        
        float m_GPS_VDOP{ 0.0f }; // field identifier = 3.
        
};
}}}}

template<>
struct isVisitable<opendlv::device::gps::peak::Delusion> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::device::gps::peak::Delusion> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_DEVICE_GPS_PEAK_IO_HPP
#define OPENDLV_DEVICE_GPS_PEAK_IO_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace device { namespace gps { namespace peak {
using namespace std::string_literals; // NOLINT
class LIB_API IO {
    private:
        static constexpr const char* TheShortName = "IO";
        static constexpr const char* TheLongName = "opendlv.device.gps.peak.IO";

    public:
        inline static int32_t ID() {
            return 1804;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        IO() = default;
        IO(const IO&) = default;
        IO& operator=(const IO&) = default;
        IO(IO&&) = default;
        IO& operator=(IO&&) = default;
        ~IO() = default;

    public:
        
        inline IO& din1Status(const bool &v) noexcept {
            m_din1Status = v;
            return *this;
        }
        inline bool din1Status() const noexcept {
            return m_din1Status;
        }
        
        inline IO& din2Status(const bool &v) noexcept {
            m_din2Status = v;
            return *this;
        }
        inline bool din2Status() const noexcept {
            return m_din2Status;
        }
        
        inline IO& doutStatus(const bool &v) noexcept {
            m_doutStatus = v;
            return *this;
        }
        inline bool doutStatus() const noexcept {
            return m_doutStatus;
        }
        
        inline IO& SDPresent(const bool &v) noexcept {
            m_SDPresent = v;
            return *this;
        }
        inline bool SDPresent() const noexcept {
            return m_SDPresent;
        }
        
        inline IO& GPSPowerStatus(const bool &v) noexcept {
            m_GPSPowerStatus = v;
            return *this;
        }
        inline bool GPSPowerStatus() const noexcept {
            return m_GPSPowerStatus;
        }
        
        inline IO& deviceID(const uint8_t &v) noexcept {
            m_deviceID = v;
            return *this;
        }
        inline uint8_t deviceID() const noexcept {
            return m_deviceID;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("bool"s), std::move("din1Status"s), m_din1Status, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("bool"s), std::move("din2Status"s), m_din2Status, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("bool"s), std::move("doutStatus"s), m_doutStatus, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("bool"s), std::move("SDPresent"s), m_SDPresent, visitor);
                return;
            }
            
            if (5 == fieldId) {
                doVisit(5, std::move("bool"s), std::move("GPSPowerStatus"s), m_GPSPowerStatus, visitor);
                return;
            }
            
            if (6 == fieldId) {
                doVisit(6, std::move("uint8_t"s), std::move("deviceID"s), m_deviceID, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("bool"s), std::move("din1Status"s), m_din1Status, visitor);
            
            doVisit(2, std::move("bool"s), std::move("din2Status"s), m_din2Status, visitor);
            
            doVisit(3, std::move("bool"s), std::move("doutStatus"s), m_doutStatus, visitor);
            
            doVisit(4, std::move("bool"s), std::move("SDPresent"s), m_SDPresent, visitor);
            
            doVisit(5, std::move("bool"s), std::move("GPSPowerStatus"s), m_GPSPowerStatus, visitor);
            
            doVisit(6, std::move("uint8_t"s), std::move("deviceID"s), m_deviceID, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("bool"s), std::move("din1Status"s), m_din1Status, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("bool"s), std::move("din2Status"s), m_din2Status, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("bool"s), std::move("doutStatus"s), m_doutStatus, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("bool"s), std::move("SDPresent"s), m_SDPresent, preVisit, visit, postVisit);
            
            doTripletForwardVisit(5, std::move("bool"s), std::move("GPSPowerStatus"s), m_GPSPowerStatus, preVisit, visit, postVisit);
            
            doTripletForwardVisit(6, std::move("uint8_t"s), std::move("deviceID"s), m_deviceID, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        bool m_din1Status{ false }; // field identifier = 1.
        
        bool m_din2Status{ false }; // field identifier = 2.
        
        bool m_doutStatus{ false }; // field identifier = 3.
        
        bool m_SDPresent{ false }; // field identifier = 4.
        
        bool m_GPSPowerStatus{ false }; // field identifier = 5.
        
        uint8_t m_deviceID{ 0 }; // field identifier = 6.
        
};
}}}}

template<>
struct isVisitable<opendlv::device::gps::peak::IO> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::device::gps::peak::IO> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_DEVICE_GPS_PEAK_UTCDATETIME_HPP
#define OPENDLV_DEVICE_GPS_PEAK_UTCDATETIME_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace device { namespace gps { namespace peak {
using namespace std::string_literals; // NOLINT
class LIB_API UTCDateTime {
    private:
        static constexpr const char* TheShortName = "UTCDateTime";
        static constexpr const char* TheLongName = "opendlv.device.gps.peak.UTCDateTime";

    public:
        inline static int32_t ID() {
            return 1805;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        UTCDateTime() = default;
        UTCDateTime(const UTCDateTime&) = default;
        UTCDateTime& operator=(const UTCDateTime&) = default;
        UTCDateTime(UTCDateTime&&) = default;
        UTCDateTime& operator=(UTCDateTime&&) = default;
        ~UTCDateTime() = default;

    public:
        
        inline UTCDateTime& UTCYear(const uint8_t &v) noexcept {
            m_UTCYear = v;
            return *this;
        }
        inline uint8_t UTCYear() const noexcept {
            return m_UTCYear;
        }
        
        inline UTCDateTime& UTCMonth(const uint8_t &v) noexcept {
            m_UTCMonth = v;
            return *this;
        }
        inline uint8_t UTCMonth() const noexcept {
            return m_UTCMonth;
        }
        
        inline UTCDateTime& UTCDayOfMonth(const uint8_t &v) noexcept {
            m_UTCDayOfMonth = v;
            return *this;
        }
        inline uint8_t UTCDayOfMonth() const noexcept {
            return m_UTCDayOfMonth;
        }
        
        inline UTCDateTime& UTCHour(const uint8_t &v) noexcept {
            m_UTCHour = v;
            return *this;
        }
        inline uint8_t UTCHour() const noexcept {
            return m_UTCHour;
        }
        
        inline UTCDateTime& UTCMinute(const uint8_t &v) noexcept {
            m_UTCMinute = v;
            return *this;
        }
        inline uint8_t UTCMinute() const noexcept {
            return m_UTCMinute;
        }
        
        inline UTCDateTime& UTCSecond(const uint8_t &v) noexcept {
            m_UTCSecond = v;
            return *this;
        }
        inline uint8_t UTCSecond() const noexcept {
            return m_UTCSecond;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("uint8_t"s), std::move("UTCYear"s), m_UTCYear, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("uint8_t"s), std::move("UTCMonth"s), m_UTCMonth, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("uint8_t"s), std::move("UTCDayOfMonth"s), m_UTCDayOfMonth, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("uint8_t"s), std::move("UTCHour"s), m_UTCHour, visitor);
                return;
            }
            
            if (5 == fieldId) {
                doVisit(5, std::move("uint8_t"s), std::move("UTCMinute"s), m_UTCMinute, visitor);
                return;
            }
            
            if (6 == fieldId) {
                doVisit(6, std::move("uint8_t"s), std::move("UTCSecond"s), m_UTCSecond, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("uint8_t"s), std::move("UTCYear"s), m_UTCYear, visitor);
            
            doVisit(2, std::move("uint8_t"s), std::move("UTCMonth"s), m_UTCMonth, visitor);
            
            doVisit(3, std::move("uint8_t"s), std::move("UTCDayOfMonth"s), m_UTCDayOfMonth, visitor);
            
            doVisit(4, std::move("uint8_t"s), std::move("UTCHour"s), m_UTCHour, visitor);
            
            doVisit(5, std::move("uint8_t"s), std::move("UTCMinute"s), m_UTCMinute, visitor);
            
            doVisit(6, std::move("uint8_t"s), std::move("UTCSecond"s), m_UTCSecond, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("uint8_t"s), std::move("UTCYear"s), m_UTCYear, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("uint8_t"s), std::move("UTCMonth"s), m_UTCMonth, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("uint8_t"s), std::move("UTCDayOfMonth"s), m_UTCDayOfMonth, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("uint8_t"s), std::move("UTCHour"s), m_UTCHour, preVisit, visit, postVisit);
            
            doTripletForwardVisit(5, std::move("uint8_t"s), std::move("UTCMinute"s), m_UTCMinute, preVisit, visit, postVisit);
            
            doTripletForwardVisit(6, std::move("uint8_t"s), std::move("UTCSecond"s), m_UTCSecond, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        uint8_t m_UTCYear{ 0 }; // field identifier = 1.
        
        uint8_t m_UTCMonth{ 0 }; // field identifier = 2.
        
        uint8_t m_UTCDayOfMonth{ 0 }; // field identifier = 3.
        
        uint8_t m_UTCHour{ 0 }; // field identifier = 4.
        
        uint8_t m_UTCMinute{ 0 }; // field identifier = 5.
        
        uint8_t m_UTCSecond{ 0 }; // field identifier = 6.
        
};
}}}}

template<>
struct isVisitable<opendlv::device::gps::peak::UTCDateTime> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::device::gps::peak::UTCDateTime> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_DEVICE_GPS_PEAK_RTCDATETIME_HPP
#define OPENDLV_DEVICE_GPS_PEAK_RTCDATETIME_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace device { namespace gps { namespace peak {
using namespace std::string_literals; // NOLINT
class LIB_API RTCDateTime {
    private:
        static constexpr const char* TheShortName = "RTCDateTime";
        static constexpr const char* TheLongName = "opendlv.device.gps.peak.RTCDateTime";

    public:
        inline static int32_t ID() {
            return 1806;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        RTCDateTime() = default;
        RTCDateTime(const RTCDateTime&) = default;
        RTCDateTime& operator=(const RTCDateTime&) = default;
        RTCDateTime(RTCDateTime&&) = default;
        RTCDateTime& operator=(RTCDateTime&&) = default;
        ~RTCDateTime() = default;

    public:
        
        inline RTCDateTime& RTCSec(const uint8_t &v) noexcept {
            m_RTCSec = v;
            return *this;
        }
        inline uint8_t RTCSec() const noexcept {
            return m_RTCSec;
        }
        
        inline RTCDateTime& RTCMin(const uint8_t &v) noexcept {
            m_RTCMin = v;
            return *this;
        }
        inline uint8_t RTCMin() const noexcept {
            return m_RTCMin;
        }
        
        inline RTCDateTime& RTCHour(const uint8_t &v) noexcept {
            m_RTCHour = v;
            return *this;
        }
        inline uint8_t RTCHour() const noexcept {
            return m_RTCHour;
        }
        
        inline RTCDateTime& RTCDayOfWeek(const uint8_t &v) noexcept {
            m_RTCDayOfWeek = v;
            return *this;
        }
        inline uint8_t RTCDayOfWeek() const noexcept {
            return m_RTCDayOfWeek;
        }
        
        inline RTCDateTime& RTCDayOfMonth(const uint8_t &v) noexcept {
            m_RTCDayOfMonth = v;
            return *this;
        }
        inline uint8_t RTCDayOfMonth() const noexcept {
            return m_RTCDayOfMonth;
        }
        
        inline RTCDateTime& RTCMonth(const uint8_t &v) noexcept {
            m_RTCMonth = v;
            return *this;
        }
        inline uint8_t RTCMonth() const noexcept {
            return m_RTCMonth;
        }
        
        inline RTCDateTime& RTCYear(const uint16_t &v) noexcept {
            m_RTCYear = v;
            return *this;
        }
        inline uint16_t RTCYear() const noexcept {
            return m_RTCYear;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("uint8_t"s), std::move("RTCSec"s), m_RTCSec, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("uint8_t"s), std::move("RTCMin"s), m_RTCMin, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("uint8_t"s), std::move("RTCHour"s), m_RTCHour, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("uint8_t"s), std::move("RTCDayOfWeek"s), m_RTCDayOfWeek, visitor);
                return;
            }
            
            if (5 == fieldId) {
                doVisit(5, std::move("uint8_t"s), std::move("RTCDayOfMonth"s), m_RTCDayOfMonth, visitor);
                return;
            }
            
            if (6 == fieldId) {
                doVisit(6, std::move("uint8_t"s), std::move("RTCMonth"s), m_RTCMonth, visitor);
                return;
            }
            
            if (7 == fieldId) {
                doVisit(7, std::move("uint16_t"s), std::move("RTCYear"s), m_RTCYear, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("uint8_t"s), std::move("RTCSec"s), m_RTCSec, visitor);
            
            doVisit(2, std::move("uint8_t"s), std::move("RTCMin"s), m_RTCMin, visitor);
            
            doVisit(3, std::move("uint8_t"s), std::move("RTCHour"s), m_RTCHour, visitor);
            
            doVisit(4, std::move("uint8_t"s), std::move("RTCDayOfWeek"s), m_RTCDayOfWeek, visitor);
            
            doVisit(5, std::move("uint8_t"s), std::move("RTCDayOfMonth"s), m_RTCDayOfMonth, visitor);
            
            doVisit(6, std::move("uint8_t"s), std::move("RTCMonth"s), m_RTCMonth, visitor);
            
            doVisit(7, std::move("uint16_t"s), std::move("RTCYear"s), m_RTCYear, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("uint8_t"s), std::move("RTCSec"s), m_RTCSec, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("uint8_t"s), std::move("RTCMin"s), m_RTCMin, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("uint8_t"s), std::move("RTCHour"s), m_RTCHour, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("uint8_t"s), std::move("RTCDayOfWeek"s), m_RTCDayOfWeek, preVisit, visit, postVisit);
            
            doTripletForwardVisit(5, std::move("uint8_t"s), std::move("RTCDayOfMonth"s), m_RTCDayOfMonth, preVisit, visit, postVisit);
            
            doTripletForwardVisit(6, std::move("uint8_t"s), std::move("RTCMonth"s), m_RTCMonth, preVisit, visit, postVisit);
            
            doTripletForwardVisit(7, std::move("uint16_t"s), std::move("RTCYear"s), m_RTCYear, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        uint8_t m_RTCSec{ 0 }; // field identifier = 1.
        
        uint8_t m_RTCMin{ 0 }; // field identifier = 2.
        
        uint8_t m_RTCHour{ 0 }; // field identifier = 3.
        
        uint8_t m_RTCDayOfWeek{ 0 }; // field identifier = 4.
        
        uint8_t m_RTCDayOfMonth{ 0 }; // field identifier = 5.
        
        uint8_t m_RTCMonth{ 0 }; // field identifier = 6.
        
        uint16_t m_RTCYear{ 0 }; // field identifier = 7.
        
};
}}}}

template<>
struct isVisitable<opendlv::device::gps::peak::RTCDateTime> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::device::gps::peak::RTCDateTime> {
    static const bool value = true;
};
#endif

